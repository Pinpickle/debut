/*! oliver-and-swan 2014-02-05 */
!function(exports, global) {
    function Animation(fun, params) {
        this.params = params, console.log(this.constructor.name), this.start = "onstep", 
        this.delay = 0, this._elem = null, this.run = function(context, reverse) {
            var nparams = this.params;
            reverse && (nparams = $.extend({}, this.params, {
                direction: -this.params.direction
            })), console.log(nparams.direction), fun(this._elem, context, nparams, function() {});
        };
    }
    function toCamelCase(str, seperator) {
        return "undefined" == typeof seperator && (seperator = "-"), str.split(seperator).map(function(e, i) {
            return 0 === i ? e.charAt(0).toLowerCase() + e.slice(1) : e.charAt(0).toUpperCase() + e.slice(1);
        }).join("");
    }
    global["true"] = exports;
    var $ = jQuery, animations = {
        appear: function(elem, context, params, callback) {
            1 === params.direction ? $(elem).css("opacity", 1) : -1 === params.direction && $(elem).css("opacity", 0), 
            callback();
        },
        slide: function(elem, context, params) {
            var leftShift = 0, topShift = 0;
            switch (params = $.extend({
                side: "left"
            }, params), 1 === params.direction && $(elem).css({
                x: 0,
                y: 0
            }), $(elem).css("opacity", 1), params.side) {
              default:
              case "left":
                leftShift = -($(elem).width() + $(elem).offset().left - context.innerContainer.offset().left);
                break;

              case "right":
                leftShift = context.innerContainer.width() - ($(elem).offset().left - context.innerContainer.offset().left);
                break;

              case "top":
                topShift = -($(elem).height() + $(elem).offset().top - context.innerContainer.offset().top);
                break;

              case "bottom":
                topShift = context.innerContainer.height() - ($(elem).offset().top - context.innerContainer.offset().top);
            }
            1 === params.direction && $(elem).css({
                x: "+=" + params.direction * leftShift,
                y: "+=" + params.direction * topShift
            }), console.log({
                x: "+=" + -params.direction * leftShift,
                y: "+=" + -params.direction * topShift
            }), $(elem).transit({
                x: "+=" + -params.direction * leftShift,
                y: "+=" + -params.direction * topShift
            }, params.duration, params.easing, params.callback);
        }
    }, slideMasterOptions = [ {
        key: "letterbox",
        type: "boolean",
        "default": !1
    }, {
        key: "aspect-ratio",
        type: function(val) {
            var arr = val.split(":");
            return parseFloat(arr[0]) / parseFloat(arr[1]);
        },
        "default": 16 / 9
    }, {
        key: "container-height",
        type: "number",
        "default": 500
    } ], presentationObjectOptions = [ {
        key: "anim",
        type: "animation",
        "default": null
    }, {
        key: "end-exit-children",
        type: "boolean",
        "default": !1
    }, {
        key: "end-exit",
        type: "animation",
        "default": null
    } ], animationQueue = [], OliverAndSwan = function() {
        this.innerContainer = null, this.outerContainer = null;
    };
    $.fn.getDOMOptions = function(template) {
        var i, attr, type, key, val, options = {};
        for (i in template) {
            if (key = toCamelCase(template[i].key), attr = this.attr("data-" + template[i].key), 
            console.log(key + ": " + attr), "undefined" != typeof attr) switch (type = template[i].type, 
            typeof type) {
              case "string":
                switch (type) {
                  case "boolean":
                    options[key] = !1, (attr || "" === attr) && (options[key] = !0);
                    break;

                  case "number":
                  case "float":
                    val = parseFloat(attr), isNaN(val) ? "" === attr && (options[key] = 0) : options[key] = val;
                    break;

                  case "animation":
                    var anim = attr, parsed = attr ? attr.match(/([^{]*){(.+)/) : null, params = {};
                    parsed && (params = eval("({" + parsed[2] + ")"), anim = parsed[1]), options[key] = anim in animations ? new Animation(animations[anim], params) : new Animation(animations.appear, params);
                    break;

                  case "string":
                  default:
                    options[key] = attr;
                }
                break;

              case "function":
                val = type(attr), "undefined" != typeof val && (options[key] = val);
                break;

              default:
                options[key] = attr;
            }
            options.hasOwnProperty(key) || (options[key] = template[i].default);
        }
        return options;
    }, $.fn.present = function(options) {
        var containerHeight, containerWidth, masterWidth, masterHeight, container = $('<div class="presentation-container"></div>'), slideMaster = this, domOptions = this.getDOMOptions(slideMasterOptions), context = new OliverAndSwan();
        this.addClass("slide-master"), options = $.extend({}, domOptions, options), containerHeight = options.containerHeight, 
        containerWidth = containerHeight * options.aspectRatio, container.height(containerHeight), 
        container.width(containerWidth), container.css("transform-origin", "0 0"), $(window).resize(function() {
            var ratio, scale;
            (slideMaster.width() != masterWidth || slideMaster.height() != masterHeight) && (masterWidth = slideMaster.width(), 
            masterHeight = slideMaster.height(), ratio = masterWidth / masterHeight, ratio > options.aspectRatio ? (scale = masterHeight / containerHeight, 
            container.css({
                left: (masterWidth - scale * containerWidth) / 2,
                top: 0
            })) : (scale = masterWidth / containerWidth, container.css({
                left: 0,
                top: (masterHeight - scale * containerHeight) / 2
            })), container.css("scale", scale));
        }), this.children("*").appendTo(container), container.appendTo(this), context.outerContainer = $(this), 
        context.innerContainer = container;
        var addChildren = function() {
            var options = $(this).getDOMOptions(presentationObjectOptions), elem = $(this);
            if (options.anim && (elem.css("opacity", 0), options.anim.params = $.extend({}, {
                direction: 1,
                duration: 500,
                easing: "in-out"
            }, options.anim.params), options.anim._elem = elem, animationQueue.push(options.anim)), 
            $(this).children().each(addChildren), options.endExitChildren) {
                var queue = [];
                $(this).children().each(function(key, val) {
                    childrenExit(queue, val);
                }), animationQueue.push(queue);
            } else options.endExit && (options.endExit.params = $.extend({}, {
                direction: -1,
                duration: 500,
                easing: "in-out"
            }, options.endExit.params), options.endExit._elem = elem, animationQueue.push(options.endExit));
        }, childrenExit = function(queue, elem) {
            var options = $(elem).getDOMOptions(presentationObjectOptions);
            elem = $(elem), (options.anim || !options.exit) && (options.exit = $.extend(!0, new Animation(), options.anim)), 
            options.exit && (options.exit.params = $.extend({}, {
                direction: -1,
                duration: 500,
                easing: "in-out"
            }, options.exit.params), options.exit._elem = elem, queue.push(options.exit)), $(this).children().each(function(key, val) {
                childrenExit(queue, val);
            });
        };
        container.children().each(addChildren);
        var ind = 0;
        $(window).keydown(function(e) {
            if (39 === e.which || 37 === e.which) {
                var fun, type, reverse = 37 === e.which;
                if (reverse) {
                    if (0 >= ind) return;
                    ind -= 1;
                } else if (ind >= animationQueue.length) return;
                if (fun = animationQueue[ind], type = fun.constructor.name, "Animation" === type) fun.run(context, reverse); else {
                    if ("Array" !== type) throw new Error("Unsupported animation type");
                    $(fun).each(function(key, val) {
                        val.run(context, reverse);
                    });
                }
                reverse || (ind += 1);
            }
        });
    };
}({}, function() {
    return this;
}());